#y variable is ordered
if(all(checking_if_already_ordered)==TRUE){
#y_var is already numerically ordered
print("y variable is already numerically ordered. If untrue, please redefine y_order as a vector with ordering.",quote = FALSE)
subsetted_df_to_analyze<-df_to_analyze_without_na[,names(df_to_analyze_without_na)%in%c(x_var,y_var)]
}else{
#y_var is not already numerically ordered
print("y variable is not yet numerically ordered, and ascending order will be assigned using y_order.",quote=FALSE)
#apply y_order as levels to y_var and convert to numeric
subsetted_df_to_analyze<-df_to_analyze_without_na[,names(df_to_analyze_without_na)%in%c(x_var,y_var)]
subsetted_df_to_analyze[[y_var]]<-factor(subsetted_df_to_analyze[[y_var]],ordered = TRUE)
levels(subsetted_df_to_analyze[[y_var]])<-y_order
subsetted_df_to_analyze[[y_var]]<-as.numeric(subsetted_df_to_analyze[[y_var]])
y_order_to_print<-paste(y_order, collapse=", ")
print(paste("The y variable is ordinal with levels in ascending order: ",y_order_to_print,".",sep="",collapse=""),quote = FALSE)
}
#Run the ordinal tests once the y variable is converted into a numeric
subsetted_df_to_analyze[[x_var]]<-as.factor(subsetted_df_to_analyze[[x_var]])
print(table(subsetted_df_to_analyze))
if(class(subsetted_df_to_analyze[[y_var]])!="numeric"){
print("Error: either y_order is unspecified for a non-numerical y variable, or your numerical y variable is not read as a numeric.",quote = FALSE)
}
cat(paste("","","",sep="\n"))
#Kruskal Wallis
formula_x_text<-paste("`",x_var,"`",sep="")
formula_y_text<-paste("`",y_var,"`",sep="")
formula_text<-paste(formula_y_text,formula_x_text,sep="~")
kruskal_test_formula<-as.formula(formula_text)
kruskal_test_result<-kruskal.test(data=subsetted_df_to_analyze,kruskal_test_formula)
print(kruskal_test_result)
cat(paste("","","",sep="\n"))
#Post-hoc Dunn's Test
print("Dunn's Post-hoc Test:",quote=FALSE)
require(dunn.test)
dunn.test(x=subsetted_df_to_analyze[[y_var]],g=subsetted_df_to_analyze[[x_var]],method="BH",kw=FALSE,list=TRUE,table=FALSE,altp = TRUE)
}else{
#y variable is numerical
subsetted_df_to_analyze<-df_to_analyze_without_na[,names(df_to_analyze_without_na)%in%c(x_var,y_var)]
#Testing for normality
looped_normality_output<-with(data=df_to_analyze_without_na,tapply(df_to_analyze_without_na[[y_var]],df_to_analyze_without_na[[x_var]],shapiro.test))
print(looped_normality_output)
normality.p.values<-c()
normality.p.value_names<-c()
for (i in 1:length(looped_normality_output)) {
normality.p.values[i]<-looped_normality_output[[i]]$p.value
normality.p.value_names[i]<-names(looped_normality_output)[i]
}
names(normality.p.values)<-normality.p.value_names
cat(paste("","",sep="\n"))
normality_p_values_to_print<-paste(signif(normality.p.values,digits = 4), collapse=", ")
print(paste("p-values from testing x variable normality:",normality_p_values_to_print),quote=FALSE)
#Printing the sample sizes
x_group_names<-c()
x_group_sample_sizes<-c()
for (i in 1:length(unique(subsetted_df_to_analyze[[x_var]]))){
x_group_names[i]<-unique(subsetted_df_to_analyze[[x_var]])[i]
x_group_sample_sizes[i]<-length(subsetted_df_to_analyze[which(subsetted_df_to_analyze[[x_var]] == unique(subsetted_df_to_analyze[[x_var]])[i]),][[x_var]])
}
names(x_group_sample_sizes)<-x_group_names
cat(paste("","",sep="\n"))
sample_size_df<-data.frame(x_group_names,x_group_sample_sizes)
sample_size_names<-c("x Variable Group","Sample Size")
colnames(sample_size_df)<-sample_size_names
print(sample_size_df,row.names=F)
cat(paste("","",sep="\n"))
#Determines whether to run parametric or non-parametric tests
parametric_or_not_vector<-c()
for (i in 1:length(normality.p.values)) {
sample_size_column<-match(names(normality.p.values)[i],names(x_group_sample_sizes))
parametric_or_not_vector[i]<-(15<x_group_sample_sizes[sample_size_column]&&normality.p.values[i]>0.05)|x_group_sample_sizes[sample_size_column]>30
}
if(all(parametric_or_not_vector==TRUE)){
print("There is normality and a sufficient sample size to run a parametric test.", quote = FALSE)
subsetted_df_to_analyze[[x_var]]<-as.factor(subsetted_df_to_analyze[[x_var]])
#Gives a summary of each group
for (i in 1:length(unique(subsetted_df_to_analyze[[x_var]]))){
cat(paste("","",sep="\n"))
df_with_i_x_group <- subsetted_df_to_analyze[which(subsetted_df_to_analyze[[x_var]] == unique(subsetted_df_to_analyze[[x_var]])[i]),]
print(summary(df_with_i_x_group))
print(paste("Standard Deviation:",signif(sd(df_with_i_x_group[[y_var]]),digits = 4)),quote=FALSE)
}
cat(paste("","","",sep="\n"))
#Checks for homogeneity of variances
require(car)
formula_x_text<-paste("`",x_var,"`",sep="")
formula_y_text<-paste("`",y_var,"`",sep="")
x_y_formula_text<-paste(formula_y_text,formula_x_text,sep="~")
formula_y_by_x<-as.formula(x_y_formula_text)
levene_result<-leveneTest(data=subsetted_df_to_analyze,formula_y_by_x)
print(levene_result)
cat(paste("","","",sep="\n"))
#Defines output based on homogeneity of variance
if(levene_result$`Pr(>F)`[1]>0.05){
print("Levene's Test is insignificant: the variances of x groups are assumed to be homogenous.",quote = FALSE)
cat(paste("","",sep="\n"))
#One-way ANOVA with Tukey's Honestly Signficant Differences post-hoc
parametric_anova_result<-aov(data = subsetted_df_to_analyze,subsetted_df_to_analyze[[y_var]]~subsetted_df_to_analyze[[x_var]])
print("One-way ANOVA:",quote=FALSE)
print(summary(parametric_anova_result))
cat(paste("","",sep="\n"))
print(TukeyHSD(parametric_anova_result))
}else if(levene_result$`Pr(>F)`[1]<=0.05){
print("Levene's Test is significant: the variances of x groups are heterogenous.",quote = FALSE)
cat(paste("","",sep="\n"))
#Welch's ANOVA with Games-Howell post-hoc
print(oneway.test(data=subsetted_df_to_analyze,formula_y_by_x,var.equal = FALSE))
cat(paste("","",sep="\n"))
require(userfriendlyscience)
print("Games-Howell Post-hoc Test:",quote=FALSE)
print(posthocTGH(y=subsetted_df_to_analyze[[y_var]],x=subsetted_df_to_analyze[[x_var]],method = "games-howell",p.adjust="BH",digits = 4,formatPvalue = FALSE))
cat(paste("","",sep="\n"))
print("Method of Games-Howell post-hoc Test p value adjustment: Benjaminiâ€“Hochberg",quote=FALSE)
}else{
print("There is an error with leveneTest. The p-value could not be extracted.",quote = FALSE)
}
}else if(any(parametric_or_not_vector==FALSE)){
print("There is not normality and/or a sufficient sample size to run a parametric test; non-parametric tests will be conducted.", quote=FALSE)
subsetted_df_to_analyze[[x_var]]<-as.factor(subsetted_df_to_analyze[[x_var]])
#Gives a summary of each group
for (i in 1:length(unique(subsetted_df_to_analyze[[x_var]]))){
cat(paste("","",sep="\n"))
df_with_i_x_group <- subsetted_df_to_analyze[which(subsetted_df_to_analyze[[x_var]] == unique(subsetted_df_to_analyze[[x_var]])[i]),]
print(summary(df_with_i_x_group))
print(paste("Standard Deviation:",signif(sd(df_with_i_x_group[[y_var]]),digits = 4)),quote=FALSE)
}
cat(paste("","","",sep="\n"))
#Kruskal Wallis
formula_x_text<-paste("`",x_var,"`",sep="")
formula_y_text<-paste("`",y_var,"`",sep="")
formula_text<-paste(formula_y_text,formula_x_text,sep="~")
kruskal_test_formula<-as.formula(formula_text)
kruskal_test_result<-kruskal.test(data=subsetted_df_to_analyze,kruskal_test_formula)
print(kruskal_test_result)
cat(paste("","","",sep="\n"))
#Post-hoc Dunn's Test
require(dunn.test)
print("Dunn's Post-hoc Test:",quote=FALSE)
dunn.test(x=subsetted_df_to_analyze[[y_var]],g=subsetted_df_to_analyze[[x_var]],method="BH",kw=FALSE,list=TRUE,table=FALSE,altp = TRUE)
}else{
print("Error: The function does not know whether to run a parametric or non-parametric test for more than two independent x groups and numerical y.",quote = FALSE)
}
}
# Run group stats: 2+ dependent x groups, numerical/ordinal y -------------
}else if(stats_to_run=="Run Stats for more than two dependent x groups and numerical/ordinal y"){
#Detects if y variable is ordered or numerical
if(any(is_ordered)==TRUE){
#y variable is ordered
if(all(checking_if_already_ordered)==TRUE){
#y_var is already numerically ordered
print("y variable is already numerically ordered. If untrue, please redefine y_order as a vector with ordering.",quote = FALSE)
subsetted_df_to_analyze<-df_to_analyze_without_na[,names(df_to_analyze_without_na)%in%c(x_var,y_var,group_dependence)]
}else{
#y_var is not already numerically ordered
print("y variable is not yet numerically ordered, and ascending order will be assigned using y_order.",quote=FALSE)
#apply y_order as levels to y_var and convert to numeric
subsetted_df_to_analyze<-df_to_analyze_without_na[,names(df_to_analyze_without_na)%in%c(x_var,y_var,group_dependence)]
subsetted_df_to_analyze[[y_var]]<-factor(subsetted_df_to_analyze[[y_var]],ordered = TRUE)
levels(subsetted_df_to_analyze[[y_var]])<-y_order
subsetted_df_to_analyze[[y_var]]<-as.numeric(subsetted_df_to_analyze[[y_var]])
y_order_to_print<-paste(y_order, collapse=", ")
print(paste("The y variable is ordinal with levels in ascending order: ",y_order_to_print,".",sep="",collapse=""),quote = FALSE)
}
#Gives Summary of Each Group
subsetted_df_to_analyze[[x_var]]<-factor(subsetted_df_to_analyze[[x_var]],levels = unique(subsetted_df_to_analyze[[x_var]]))
summary_df<-subsetted_df_to_analyze[ , !(names(subsetted_df_to_analyze) %in% group_dependence)]
print(table(summary_df))
if(class(subsetted_df_to_analyze[[y_var]])!="numeric"){
print("Error: either y_order is unspecified for a non-numerical y variable, or your numerical y variable is not read as a numeric.",quote = FALSE)
}
cat(paste("","","",sep="\n"))
#Testing for multiple observations within x_var groups using group_dependence
testing_for_repeated_group_dependence_values<-c()
for (i in 1:length(unique(subsetted_df_to_analyze[[x_var]]))) {
x_var_to_test<-subset(subsetted_df_to_analyze,subsetted_df_to_analyze[[x_var]]==unique(subsetted_df_to_analyze[[x_var]])[i])
testing_for_repeated_group_dependence_values[i]<-length(x_var_to_test[[group_dependence]])==length(unique(x_var_to_test[[group_dependence]]))
}
if(any(testing_for_repeated_group_dependence_values==FALSE)){
print("There are repeated observations within individual x_var groups; A model must be fitted.",quote=FALSE)
#Check if group_dependence is a random effect, if so then do lmer. If not do lm().
if(dependence_is_random_effect==TRUE){
#It's a random effect, so do lmer.
require(lme4)
require(lmerTest)
cat(paste("","",sep="\n"))
print("group_dependence is a random effect, so a linear mixed model will be run.",quote=F)
cat(paste("","",sep="\n"))
formula_x_text<-paste("`",x_var,"`",sep="")
formula_y_text<-paste("`",y_var,"`",sep="")
formula_group_text<-paste("`",group_dependence,"`",sep="")
formula_text1<-paste(formula_y_text,formula_x_text,sep="~")
random_slope_text<-paste("+(1+",formula_x_text,"|",formula_group_text,")",sep="")
formula_text2<-paste(formula_text1,random_slope_text,sep="")
formula_for_lmer_with_x_effect<-as.formula(formula_text2)
lmer_with_x_effect<-lmer(data=subsetted_df_to_analyze,formula_for_lmer_with_x_effect,REML=F)
formula_text_for_lmer_without_x_effect<-paste(formula_y_text,"~1+(1|",formula_group_text,")",sep="")
formula_for_lmer_without_x_effect<-as.formula(formula_text_for_lmer_without_x_effect)
lmer_without_x_effect<-lmer(data=subsetted_df_to_analyze,formula_for_lmer_without_x_effect,REML=F)
#Creates output
print(anova(lmer_without_x_effect,lmer_with_x_effect))
cat(paste("","","","",sep="\n"))
print(paste("Linear Mixed Model comparing against reference group:"," '",levels(subsetted_df_to_analyze[[x_var]])[1],"'",sep=""),quote=FALSE)
cat(paste("","","",sep="\n"))
print(summary(lmer_with_x_effect))
}else if(dependence_is_random_effect==FALSE){
#It's a fixed effect, so do lm()
cat(paste("","",sep="\n"))
print("group_dependence is a fixed effect, so a multivariable linear model will be run.",quote=F)
cat(paste("","",sep="\n"))
formula_x_text<-paste("`",x_var,"`",sep="")
formula_y_text<-paste("`",y_var,"`",sep="")
formula_group_dependence_text<-paste("`",group_dependence,"`",sep="")
formula_y_by_x<-paste(formula_y_text,formula_x_text,sep="~")
formula_text<-paste(formula_y_by_x,formula_group_dependence_text,sep="*")
linear_model_formula<-as.formula(formula_text)
print(summary(aov(data = subsetted_df_to_analyze,linear_model_formula)))
cat(paste("","","",sep="\n"))
print(paste("OLS linear model comparing against reference group:"," '",levels(subsetted_df_to_analyze[[x_var]])[1],"'",sep=""),quote=FALSE)
print(summary(lm(data = subsetted_df_to_analyze,linear_model_formula,model = TRUE)))
}else{
print("Error: dependence_is_random_effect has an invalid value (not y or n).",quote=F)
}
}else if(all(testing_for_repeated_group_dependence_values==TRUE)){
print("There are no repeated observations within individual x_var groups. Normal tests will be run.",quote=FALSE)
#Remove corresponding (according to group_dependence) observations to those removed earlier due to NAs
cat(paste("","","",sep="\n"))
no_of_groups<-length(unique(subsetted_df_to_analyze[[x_var]]))
for (i in length(unique(subsetted_df_to_analyze[[group_dependence]])):1) {
if (no_of_groups>length((subsetted_df_to_analyze[which(subsetted_df_to_analyze[[group_dependence]] == unique(subsetted_df_to_analyze[[group_dependence]])[i]),][[y_var]]))){
val_to_remove<-unique(subsetted_df_to_analyze[[group_dependence]])[i]
cat("Removing",val_to_remove,"from analysis as it has missing y_var values.","\n")
subsetted_df_to_analyze<-subsetted_df_to_analyze[subsetted_df_to_analyze[[group_dependence]]!=val_to_remove,]
}
}
cat(paste("","","",sep="\n"))
#Friedman Test
formula_x_text<-paste("`",x_var,"`",sep="")
formula_y_text<-paste("`",y_var,"`",sep="")
formula_group_text<-paste("`",group_dependence,"`",sep="")
formula_y_by_x<-paste(formula_y_text,formula_x_text,sep="~")
formula_text<-paste(formula_y_by_x,formula_group_text,sep="|")
friedman_test_formula<-as.formula(formula_text)
print(friedman.test(friedman_test_formula,data = subsetted_df_to_analyze))
cat(paste("","","",sep="\n"))
#Post-hoc tests
require(PMCMRplus)
print(posthoc.friedman.nemenyi.test(friedman_test_formula,data = subsetted_df_to_analyze))
cat("Note: Nemenyi's post-hoc tests naturally account for the inflation of family-wise/Type I error,\nso p-value adjustment is unnecessary.")
}else{
print("There is an error - the function cannot detect, for at least one x_var group, whether group_dependence has any repeated values; The function does not know whether to run a linear model or another test.",quote=FALSE)
}
}else{
#y variable is numerical
subsetted_df_to_analyze<-df_to_analyze_without_na[,names(df_to_analyze_without_na)%in%c(x_var,y_var,group_dependence)]
#Testing for normality
looped_normality_output<-with(data=df_to_analyze_without_na,tapply(df_to_analyze_without_na[[y_var]],df_to_analyze_without_na[[x_var]],shapiro.test))
print(looped_normality_output)
normality.p.values<-c()
normality.p.value_names<-c()
for (i in 1:length(looped_normality_output)) {
normality.p.values[i]<-looped_normality_output[[i]]$p.value
normality.p.value_names[i]<-names(looped_normality_output)[i]
}
names(normality.p.values)<-normality.p.value_names
cat(paste("","",sep="\n"))
normality_p_values_to_print<-paste(signif(normality.p.values,digits = 4), collapse=", ")
print(paste("p-values from testing x variable normality:",normality_p_values_to_print),quote=FALSE)
#Printing the sample sizes
x_group_names<-c()
x_group_sample_sizes<-c()
for (i in 1:length(unique(subsetted_df_to_analyze[[x_var]]))){
x_group_names[i]<-unique(subsetted_df_to_analyze[[x_var]])[i]
x_group_sample_sizes[i]<-length(subsetted_df_to_analyze[which(subsetted_df_to_analyze[[x_var]] == unique(subsetted_df_to_analyze[[x_var]])[i]),][[x_var]])
}
names(x_group_sample_sizes)<-x_group_names
cat(paste("","",sep="\n"))
sample_size_df<-data.frame(x_group_names,x_group_sample_sizes)
sample_size_names<-c("x Variable Group","Sample Size")
colnames(sample_size_df)<-sample_size_names
print(sample_size_df,row.names=F)
cat(paste("","",sep="\n"))
#Determines whether to run parametric or non-parametric tests
parametric_or_not_vector<-c()
for (i in 1:length(normality.p.values)) {
sample_size_column<-match(names(normality.p.values)[i],names(x_group_sample_sizes))
parametric_or_not_vector[i]<-(15<x_group_sample_sizes[sample_size_column]&&normality.p.values[i]>0.05)|x_group_sample_sizes[sample_size_column]>30
}
if(all(parametric_or_not_vector==TRUE)){
print("There is normality and a sufficient sample size to run a parametric test.", quote = FALSE)
subsetted_df_to_analyze[[x_var]]<-as.factor(subsetted_df_to_analyze[[x_var]])
#Gives a summary of each group
for (i in 1:length(unique(subsetted_df_to_analyze[[x_var]]))){
cat(paste("","",sep="\n"))
df_with_i_x_group <- subsetted_df_to_analyze[which(subsetted_df_to_analyze[[x_var]] == unique(subsetted_df_to_analyze[[x_var]])[i]),]
print(summary(df_with_i_x_group))
print(paste("Standard Deviation:",signif(sd(df_with_i_x_group[[y_var]]),digits = 4)),quote=FALSE)
}
cat(paste("","","",sep="\n"))
#Testing for multiple observations within x_var groups using group_dependence
testing_for_repeated_group_dependence_values<-c()
for (i in 1:length(unique(subsetted_df_to_analyze[[x_var]]))) {
x_var_to_test<-subset(subsetted_df_to_analyze,subsetted_df_to_analyze[[x_var]]==unique(subsetted_df_to_analyze[[x_var]])[i])
testing_for_repeated_group_dependence_values[i]<-length(x_var_to_test[[group_dependence]])==length(unique(x_var_to_test[[group_dependence]]))
}
if(any(testing_for_repeated_group_dependence_values==FALSE)){
print("There are repeated observations within individual x_var groups; A model must be fitted.",quote=FALSE)
#Check if group_dependence is a random effect, if so then do lmer. If not do lm().
if(dependence_is_random_effect==TRUE){
#It's a random effect, so do lmer.
require(lme4)
require(lmerTest)
cat(paste("","",sep="\n"))
print("group_dependence is a random effect, so a linear mixed model will be run.",quote=F)
cat(paste("","",sep="\n"))
formula_x_text<-paste("`",x_var,"`",sep="")
formula_y_text<-paste("`",y_var,"`",sep="")
formula_group_text<-paste("`",group_dependence,"`",sep="")
formula_text1<-paste(formula_y_text,formula_x_text,sep="~")
random_slope_text<-paste("+(1+",formula_x_text,"|",formula_group_text,")",sep="")
formula_text2<-paste(formula_text1,random_slope_text,sep="")
formula_for_lmer_with_x_effect<-as.formula(formula_text2)
lmer_with_x_effect<-lmer(data=subsetted_df_to_analyze,formula_for_lmer_with_x_effect,REML=F)
formula_text_for_lmer_without_x_effect<-paste(formula_y_text,"~1+(1|",formula_group_text,")",sep="")
formula_for_lmer_without_x_effect<-as.formula(formula_text_for_lmer_without_x_effect)
lmer_without_x_effect<-lmer(data=subsetted_df_to_analyze,formula_for_lmer_without_x_effect,REML=F)
#Creates output
print(anova(lmer_without_x_effect,lmer_with_x_effect))
cat(paste("","","","",sep="\n"))
print(paste("Linear Mixed Model comparing against reference group:"," '",levels(subsetted_df_to_analyze[[x_var]])[1],"'",sep=""),quote=FALSE)
cat(paste("","","",sep="\n"))
print(summary(lmer_with_x_effect))
}else if(dependence_is_random_effect==FALSE){
#It's a fixed effect, so do lm()
cat(paste("","",sep="\n"))
print("group_dependence is a fixed effect, so a multivariable linear model will be run.",quote=F)
cat(paste("","",sep="\n"))
formula_x_text<-paste("`",x_var,"`",sep="")
formula_y_text<-paste("`",y_var,"`",sep="")
formula_group_dependence_text<-paste("`",group_dependence,"`",sep="")
formula_y_by_x<-paste(formula_y_text,formula_x_text,sep="~")
formula_text<-paste(formula_y_by_x,formula_group_dependence_text,sep="*")
linear_model_formula<-as.formula(formula_text)
print(summary(aov(data = subsetted_df_to_analyze,linear_model_formula)))
cat(paste("","","",sep="\n"))
print(paste("OLS linear model comparing against reference group:"," '",levels(subsetted_df_to_analyze[[x_var]])[1],"'",sep=""),quote=FALSE)
print(summary(lm(data = subsetted_df_to_analyze,linear_model_formula,model = TRUE)))
}else{
print("Error: dependence_is_random_effect has an invalid value (not y or n).",quote=F)
}
}else if(all(testing_for_repeated_group_dependence_values==TRUE)){
print("There are no repeated observations within individual x_var groups. Normal tests will be run.",quote=FALSE)
#Interval and normal: One-way repeated measures ANOVA.
require(car)
#Remove corresponding (according to group_dependence) observations to those removed earlier due to NAs
cat(paste("","","",sep="\n"))
no_of_groups<-length(unique(subsetted_df_to_analyze[[x_var]]))
for (i in length(unique(subsetted_df_to_analyze[[group_dependence]])):1) {
if (no_of_groups>length((subsetted_df_to_analyze[which(subsetted_df_to_analyze[[group_dependence]] == unique(subsetted_df_to_analyze[[group_dependence]])[i]),][[y_var]]))){
val_to_remove<-unique(subsetted_df_to_analyze[[group_dependence]])[i]
cat("Removing",val_to_remove,"from analysis as it has missing y_var values.","\n")
subsetted_df_to_analyze<-subsetted_df_to_analyze[subsetted_df_to_analyze[[group_dependence]]!=val_to_remove,]
}
}
cat(paste("","","",sep="\n"))
subsetted_df_to_analyze[[group_dependence]]<-factor(subsetted_df_to_analyze[[group_dependence]])
#Preparing the data and model parameters
require(tidyr)
wide_df<-spread(subsetted_df_to_analyze,x_var,y_var)
#This is needed for the Anova on the model design
x_var_levels<-c()
for (i in 1:length(unique(subsetted_df_to_analyze[[x_var]]))){
x_var_levels[i]<-i
}
x_var_factor<-as.factor(x_var_levels)
x_var_df<-as.data.frame(x_var_factor)
#Formatting the data
model_wide_df<-wide_df[ , !(names(wide_df) %in% group_dependence)]
model_matrix<-as.matrix(model_wide_df)
#Running the model
repeated_measures_linear_model<-lm(model_matrix~1)
repeated_measures_anova<-Anova(repeated_measures_linear_model,idata = x_var_df,idesign = ~x_var_factor,type="III")
print(summary(repeated_measures_anova,multivariate=FALSE))
#Post-hoc pairwise paired t-tests
cat(paste("","","",sep="\n"))
pairwise.t.test(x=subsetted_df_to_analyze[[y_var]],g=subsetted_df_to_analyze[[x_var]],p.adjust.method = "BH",paired = TRUE)
}else{
print("There is an error - the function cannot detect, for at least one x_var group, whether group_dependence has any repeated values; The function does not know whether to run a linear model or another test.",quote=FALSE)
}
}else if(any(parametric_or_not_vector==FALSE)){
print("There is not normality and/or a sufficient sample size to run a parametric test; non-parametric tests will be conducted.", quote=FALSE)
subsetted_df_to_analyze[[x_var]]<-factor(subsetted_df_to_analyze[[x_var]],levels = unique(subsetted_df_to_analyze[[x_var]]))
#Gives a summary of each group
for (i in 1:length(unique(subsetted_df_to_analyze[[x_var]]))){
cat(paste("","",sep="\n"))
df_with_i_x_group <- subsetted_df_to_analyze[which(subsetted_df_to_analyze[[x_var]] == unique(subsetted_df_to_analyze[[x_var]])[i]),]
print(summary(df_with_i_x_group))
print(paste("Standard Deviation:",signif(sd(df_with_i_x_group[[y_var]]),digits = 4)),quote=FALSE)
}
cat(paste("","","",sep="\n"))
#Testing for multiple observations within x_var groups using group_dependence
testing_for_repeated_group_dependence_values<-c()
for (i in 1:length(unique(subsetted_df_to_analyze[[x_var]]))) {
x_var_to_test<-subset(subsetted_df_to_analyze,subsetted_df_to_analyze[[x_var]]==unique(subsetted_df_to_analyze[[x_var]])[i])
testing_for_repeated_group_dependence_values[i]<-length(x_var_to_test[[group_dependence]])==length(unique(x_var_to_test[[group_dependence]]))
}
if(any(testing_for_repeated_group_dependence_values==FALSE)){
print("There are repeated observations within individual x_var groups; A model must be fitted.",quote=FALSE)
#Check if group_dependence is a random effect, if so then do lmer. If not do lm().
if(dependence_is_random_effect==TRUE){
#It's a random effect, so do lmer.
require(lme4)
require(lmerTest)
cat(paste("","",sep="\n"))
print("group_dependence is a random effect, so a linear mixed model will be run.",quote=F)
cat(paste("","",sep="\n"))
formula_x_text<-paste("`",x_var,"`",sep="")
formula_y_text<-paste("`",y_var,"`",sep="")
formula_group_text<-paste("`",group_dependence,"`",sep="")
formula_text1<-paste(formula_y_text,formula_x_text,sep="~")
random_slope_text<-paste("+(1+",formula_x_text,"|",formula_group_text,")",sep="")
formula_text2<-paste(formula_text1,random_slope_text,sep="")
formula_for_lmer_with_x_effect<-as.formula(formula_text2)
lmer_with_x_effect<-lmer(data=subsetted_df_to_analyze,formula_for_lmer_with_x_effect,REML=F)
formula_text_for_lmer_without_x_effect<-paste(formula_y_text,"~1+(1|",formula_group_text,")",sep="")
formula_for_lmer_without_x_effect<-as.formula(formula_text_for_lmer_without_x_effect)
lmer_without_x_effect<-lmer(data=subsetted_df_to_analyze,formula_for_lmer_without_x_effect,REML=F)
#Creates output
print(anova(lmer_without_x_effect,lmer_with_x_effect))
cat(paste("","","","",sep="\n"))
print(paste("Linear Mixed Model comparing against reference group:"," '",levels(subsetted_df_to_analyze[[x_var]])[1],"'",sep=""),quote=FALSE)
cat(paste("","","",sep="\n"))
print(summary(lmer_with_x_effect))
}else if(dependence_is_random_effect==FALSE){
#It's a fixed effect, so do lm()
cat(paste("","",sep="\n"))
print("group_dependence is a fixed effect, so a multivariable linear model will be run.",quote=F)
cat(paste("","",sep="\n"))
formula_x_text<-paste("`",x_var,"`",sep="")
formula_y_text<-paste("`",y_var,"`",sep="")
formula_group_dependence_text<-paste("`",group_dependence,"`",sep="")
formula_y_by_x<-paste(formula_y_text,formula_x_text,sep="~")
formula_text<-paste(formula_y_by_x,formula_group_dependence_text,sep="*")
linear_model_formula<-as.formula(formula_text)
print(summary(aov(data = subsetted_df_to_analyze,linear_model_formula)))
cat(paste("","","",sep="\n"))
print(paste("OLS linear model comparing against reference group:"," '",levels(subsetted_df_to_analyze[[x_var]])[1],"'",sep=""),quote=FALSE)
print(summary(lm(data = subsetted_df_to_analyze,linear_model_formula,model = TRUE)))
}else{
print("Error: dependence_is_random_effect has an invalid value (not y or n).",quote=F)
}
}else if(all(testing_for_repeated_group_dependence_values==TRUE)){
print("There are no repeated observations within individual x_var groups. Normal tests will be run.",quote=FALSE)
#Remove corresponding (according to group_dependence) observations to those removed earlier due to NAs
cat(paste("","","",sep="\n"))
no_of_groups<-length(unique(subsetted_df_to_analyze[[x_var]]))
for (i in length(unique(subsetted_df_to_analyze[[group_dependence]])):1) {
if (no_of_groups>length((subsetted_df_to_analyze[which(subsetted_df_to_analyze[[group_dependence]] == unique(subsetted_df_to_analyze[[group_dependence]])[i]),][[y_var]]))){
val_to_remove<-unique(subsetted_df_to_analyze[[group_dependence]])[i]
cat("Removing",val_to_remove,"from analysis as it has missing y_var values.","\n")
subsetted_df_to_analyze<-subsetted_df_to_analyze[subsetted_df_to_analyze[[group_dependence]]!=val_to_remove,]
}
}
cat(paste("","","",sep="\n"))
#Friedman Test
formula_x_text<-paste("`",x_var,"`",sep="")
formula_y_text<-paste("`",y_var,"`",sep="")
formula_group_text<-paste("`",group_dependence,"`",sep="")
formula_y_by_x<-paste(formula_y_text,formula_x_text,sep="~")
formula_text<-paste(formula_y_by_x,formula_group_text,sep="|")
friedman_test_formula<-as.formula(formula_text)
print(friedman.test(friedman_test_formula,data = subsetted_df_to_analyze))
cat(paste("","","",sep="\n"))
#Post-hoc tests
require(PMCMRplus)
print(posthoc.friedman.nemenyi.test(friedman_test_formula,data = subsetted_df_to_analyze))
cat("Note: Nemenyi's post-hoc tests naturally account for the inflation of family-wise/Type I error,\nso p-value adjustment is unnecessary.")
}else{
print("There is an error - the function cannot detect, for at least one x_var group, whether group_dependence has any repeated values; The function does not know whether to run a linear model or another test.",quote=FALSE)
}
}else{
print("Error: The function does not know whether to run a parametric or non-parametric test for more than two independent x groups and numerical y.",quote = FALSE)
}
}
}else{
print("Error - stats_to_run is undefined or unrecognized.")
}
}
#Analyzing_the_Preliminary_DR_Data_on_RStudio$`Fake Height`<-as.factor(Analyzing_the_Preliminary_DR_Data_on_RStudio$`Fake Height`)
run.group.stats(df_to_analyze = Analyzing_the_Preliminary_DR_Data_on_RStudio,x_var = "Diagnosis",y_var = "Max.Blue")
#Analyzing_the_Preliminary_DR_Data_on_RStudio$`Fake Height`<-as.factor(Analyzing_the_Preliminary_DR_Data_on_RStudio$`Fake Height`)
run.group.stats(df_to_analyze = Analyzing_the_Preliminary_DR_Data_on_RStudio,x_var = "Diagnosis",y_var = "Max.Blue",group_dependence = "Fake HbA1c Status")
t.test(data=Analyzing_the_Preliminary_DR_Data_on_RStudio,Max.Blue~`Fake HbA1c Status`,paired=T)
library(maxfunctions)
library(maxfunctions)
require(PMCMR)
library(maxfunctions)
library(readxl)
Analyzing_the_Preliminary_DR_Data_on_RStudio <- read_excel("~/Dropbox/SERI/Pupillometry Data/Data Analysis/Spreadsheets for Scripts/Analyzing the Preliminary DR Data on RStudio.xlsx")
View(Analyzing_the_Preliminary_DR_Data_on_RStudio)
df_to_analyze = Analyzing_the_Preliminary_DR_Data_on_RStudio
x_var = "Diagnosis"
y_var = "Max.Blue"
#Makes the x_variable a character/group - important if groups are eg 1, 2, 3, 4
levels(df_to_analyze[[x_var]])
#Makes the x_variable a character/group - important if groups are eg 1, 2, 3, 4
df_to_analyze[[x_var]]<-factor(df_to_analyze[[x_var]])
levels(df_to_analyze[[x_var]])
#Makes the x_variable a character/group - important if groups are eg 1, 2, 3, 4
x_levels<-levels(df_to_analyze[[x_var]])
library(maxfunctions)
library(maxfunctions)
library(maxfunctions)
library(maxfunctions)
